/******************************
 * Author: gymcontento herry996341591@gmail.com
 * Date: 2026-01-04 13:28:16
 * LastEditors: gymcontento herry996341591@gmail.com
 * LastEditTime: 2026-01-16 00:14:44
 * FilePath: \convection_diffusion\src\postprocess.cpp
 * Description: 
 * 
 * Copyright (c) 2026 by ${git_name_email}, All Rights Reserved. 
 ******************************/
#include "postprocess.h"
#include <vector>
#include <fstream>
#include <sstream>
#include <iomanip>

void PostProcess::WriteVTKCollocated_temp(
     StructureMesh& mesh, std::string filename)
{
    const std::vector<int>& cellnum = mesh.cellnum_export();
    const std::vector<int>& nodenum = mesh.nodenum_export();
    
    const std::vector<float>& x_nodes = mesh.xnodes_export();
    const std::vector<float>& y_nodes = mesh.ynodes_export();
    const std::vector<float>& z_nodes = mesh.znodes_export();

    const std::vector<std::vector<std::vector<float>>>& t = mesh.tfield_export();

    std::ofstream vtkFile(filename);
    if(!vtkFile.is_open())
    {
        std::cerr << "Error: Cannot open file " << filename << std::endl;
        return;
    }

    // ========== 写入 VTK 头部信息 ==========
    vtkFile << "# vtk DataFile Version 3.0\n";
    vtkFile << "VTK file generated by C++ code\n";
    vtkFile << "ASCII\n";
    vtkFile << "DATASET RECTILINEAR_GRID\n";

    // ========== 写入网格信息 ==========
    vtkFile << "DIMENSIONS " << nodenum[0] << " " << nodenum[1] << " " << nodenum[2] << "\n";
    vtkFile << "X_COORDINATES " << nodenum[0] << " " << "float\n";
    for(auto& i : x_nodes) {vtkFile << i << " ";}
    vtkFile << "\n";
    vtkFile << "Y_COORDINATES " << nodenum[1] << " " << "float\n";
    for(auto& i : y_nodes) {vtkFile << i << " ";}
    vtkFile << "\n";
    vtkFile << "Z_COORDINATES " << nodenum[2] << " " << "float\n";
    for(auto& i : z_nodes) {vtkFile << i << " ";}
    vtkFile << "\n";

    // ========== 写入单元信息 ==========
    int totalcnum = (nodenum[0] - 1) * (nodenum[1] - 1) * (nodenum[2] - 1);
    vtkFile << "CELL_DATA " << totalcnum << " " << "\n";

    //定义数据块
    vtkFile << "FIELD FieldData 1\n";

    // ========== 写入温度数据 ==========
    vtkFile << "t" << " 1 " << totalcnum << " float\n";
    // 第二行：按 Fortran 顺序展平（手动实现）
    std::vector<float> t_arr;
    t_arr.reserve(totalcnum);
    // Fortran 顺序：k (z) 在最外层
    for (int k = 0; k < cellnum[2]; ++k) {
        for (int j = 0; j < cellnum[1]; ++j) {
            for (int i = 0; i < cellnum[0]; ++i) {
                t_arr.push_back(t[i][j][k]);
            }
        }
    }
    //写入t_arr单行数组
    for (size_t i = 0; i < t_arr.size(); ++i) {
        vtkFile << t_arr[i];
        if (i < t_arr.size() - 1) {
            vtkFile << " ";
        }
    }
    vtkFile << "\n";

    vtkFile.close();
    std::cout << "VTK file written: " << filename << std::endl;
}


//针对一维特殊情况做的输出
void PostProcess::WriteVTKCollocated_temp_Pe_L(StructureMesh &mesh, MaterialSettings &material)
{
    const std::vector<int>& cellnum = mesh.cellnum_export();
    const std::vector<int>& nodenum = mesh.nodenum_export();
    
    const std::vector<float>& x_nodes = mesh.xnodes_export();
    const std::vector<float>& y_nodes = mesh.ynodes_export();
    const std::vector<float>& z_nodes = mesh.znodes_export();

    const std::vector<std::vector<std::vector<float>>>& t = mesh.tfield_export();

    const float& cond_coef = material.ConductivityExport();
    float pe_l;

    //Peclect数判断，已经设置密度和全局长度，这个deltax考虑的是全局长度，为1
    if(std::abs(cond_coef) > 100000){
         pe_l = 0.0f;
    }else{
        pe_l = mesh.initial_uf / material.ConductivityExport();
    }
    std::cout << "Check Pe_L " << pe_l << "\n";

    // Open temperature output files
    if(cellnum[1] == 1){
        std::ostringstream pe_l_filename;
        pe_l_filename << "temp_x_" << static_cast<int>(pe_l) << ".dat";
        std::ofstream _ofs(pe_l_filename.str());
        if (!_ofs.is_open()) {
            std::cerr << "Error: Cannot open file " << pe_l_filename.str() << std::endl;
            return;
        }
         // 写入温度数据（沿x方向）
        int j = 0;
        int k = 0;
        for (int i = 0; i < nodenum[0] - 1; i++) {
            double xtemp = (x_nodes[i] + x_nodes[i + 1]) * 0.5;
            _ofs << xtemp << " " << t[i][j][k] << "\n";
        } 
        _ofs.close();

        std::ostringstream anl_filename;
        anl_filename << "analytical_temp_x_" << static_cast<int>(pe_l) << ".dat";
        std::ofstream _ofs_a(anl_filename.str());
        if (!_ofs_a.is_open()) {
            std::cerr << "Error: Cannot open file " << anl_filename.str() << std::endl;
            return;
        }

        // 写入解析解数据（沿x方向）      
        if (std::abs(pe_l) < 1.0e-3) {
            // 小Pe_L情况：线性分布 T(x) = x
            for (int i = 0; i < nodenum[0] - 1; i++) {
                double xtemp = (x_nodes[i] + x_nodes[i + 1]) * 0.5;
                _ofs_a << xtemp << " " << xtemp << "\n";
            }
        } else {
            // 一般情况：指数分布 T(x) = (exp(Pe_L * x) - 1) / (exp(Pe_L) - 1)
            double exp_Pe_L = std::exp(pe_l);
            for (int i = 0; i < nodenum[0] - 1; i++) {
                double xtemp = (x_nodes[i] + x_nodes[i + 1]) * 0.5;
                double result = (std::exp(pe_l * xtemp) - 1.0) / (exp_Pe_L - 1.0);
                _ofs_a << xtemp << " " << result << "\n";
            }
        }
        
        _ofs_a.close();
    }

    if(cellnum[0] == 1){
        std::ostringstream pe_l_filename_y;
        pe_l_filename_y << "temp_y_" << static_cast<int>(pe_l) << ".dat";
        std::ofstream _ofs_y(pe_l_filename_y.str());
        if (!_ofs_y.is_open()) {
            std::cerr << "Error: Cannot open file " << pe_l_filename_y.str() << std::endl;
            return;
        }
        // 写入温度数据（沿y方向）
        int i = 0;
        int k = 0;
        for (int j = 0; j < nodenum[1] - 1; j++) {
            double ytemp = (y_nodes[j] + y_nodes[j + 1]) * 0.5;
            _ofs_y << std::scientific << std::setprecision(15) 
                << ytemp << " " << t[i][j][k] << "\n";
        }
        _ofs_y.close();

        std::ostringstream anl_filename_y;
        anl_filename_y << "analytical_temp_y_" << static_cast<int>(pe_l) << ".dat";
        std::ofstream _ofs_a_y(anl_filename_y.str());
        if (!_ofs_a_y.is_open()) {
            std::cerr << "Error: Cannot open file " << anl_filename_y.str() << std::endl;
            return;
        }

        // 写入解析解数据（沿y方向）      
        if (std::abs(pe_l) < 1.0e-3) {
            // 小Pe_L情况：线性分布 T(y) = y
            for (int j = 0; j < nodenum[1] - 1; j++) {
                double ytemp = (y_nodes[j] + y_nodes[j + 1]) * 0.5;
                _ofs_a_y << std::scientific << std::setprecision(15) 
                    << ytemp << " " << ytemp << "\n";
            }
        } else {
            // 一般情况：指数分布 T(y) = (exp(Pe_L * y) - 1) / (exp(Pe_L) - 1)
            double exp_Pe_L = std::exp(pe_l);
            for (int j = 0; j < nodenum[1] - 1; j++) {
                double ytemp = (y_nodes[j] + y_nodes[j + 1]) * 0.5;
                double result = (std::exp(pe_l * ytemp) - 1.0) / (exp_Pe_L - 1.0);
                _ofs_a_y << std::scientific << std::setprecision(15) 
                    << ytemp << " " << result << "\n";
            }
        }
        
        _ofs_a_y.close();
    }
}

void PostProcess::WriteVTKCollocated_temp_Pe_L_center(StructureMesh &mesh, MaterialSettings &material, SolverSettings& solversettings)
{
    const std::vector<int>& nodenum = mesh.nodenum_export();
    const auto& t = mesh.t;

    const auto& con = material.ConductivityExport();
    float pe_l;
    std::string outfile_name;
    //Peclect数判断，已经设置密度和全局长度，这个deltax考虑的是全局长度，为1
    if(std::abs(con) > 100000){
         pe_l = 0.0f;
    }else{
        pe_l = mesh.initial_uf / material.ConductivityExport();
    }
    std::cout << "Check Pe_L " << pe_l << "\n";

    int conv_scheme = solversettings.conv_scheme;
    std::cout << "Check conv_scheme " << conv_scheme << "\n";
    if(conv_scheme == 0){
        outfile_name = "center_temp_x_upwind.dat";
    }else if(conv_scheme == 1){
        outfile_name = "center_temp_x_center.dat";
    }

    std::ofstream _ofs(outfile_name, std::ios::app);
    //Write temperature data at center point
    int i = int(nodenum[0]/2) - 1;
    int j{0};
    int k{0};
    if (std::abs(pe_l) < 1.0e-3) {
        _ofs << pe_l << " " << t[i][j][k] << " " << 0.5f << "\n";
    }else{
        float xtemp = 0.5f;
        float exp_pe_l = std::exp(pe_l);
        float result = (std::exp(pe_l * xtemp) - 1.0f) / (exp_pe_l - 1.0f);

        _ofs << pe_l << " " << t[i][j][k] << " " << result << "\n";
    }
}

void PostProcess::SetOuputFreq(const int &res_freq, const int &out_freq)
{
    resfreq = res_freq;
    outfreq = out_freq;
}
